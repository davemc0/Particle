<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ParticleAPI: PContextActionList_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_p_a_p_i.html">PAPI</a>::<a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html">PContextActionList_t</a>
  </div>
</div>
<div class="contents">
<h1>PContextActionList_t Class Reference</h1><!-- doxytag: class="PAPI::PContextActionList_t" -->Action List Calls.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="p_a_p_i_8h-source.html">pAPI.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PContextActionList_t:</div>
<div class="dynsection">

<p><center><img src="class_p_a_p_i_1_1_p_context_action_list__t.png" usemap="#PContextActionList_t_map" border="0" alt=""></center>
<map name="PContextActionList_t_map">
<area href="class_p_a_p_i_1_1_particle_context__t.html" alt="ParticleContext_t" shape="rect" coords="0,56,127,80">
</map>
</div>

<p>
<a href="class_p_a_p_i_1_1_p_context_action_list__t-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#7795db5cf91fd9fb837a83054cfe96c3">Seed</a> (const unsigned int seed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the random number seed.  <a href="#7795db5cf91fd9fb837a83054cfe96c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#0330f623cbd0686e4fd84abe6f2a3828">TimeStep</a> (const float new_dt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the time step length.  <a href="#0330f623cbd0686e4fd84abe6f2a3828"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#1fd276780b4ea073d187576f2459e1b4">CallActionList</a> (const int action_list_num)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute the specified action list on the current particle group.  <a href="#1fd276780b4ea073d187576f2459e1b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#bef97a9286180f1e53cb81a5c17e6205">DeleteActionLists</a> (const int action_list_num, const int action_list_count=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete one or more consecutive action lists.  <a href="#bef97a9286180f1e53cb81a5c17e6205"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#f0ffaad952c3b2df8bc7161deb9f9127">EndActionList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End the creation of a new action list.  <a href="#f0ffaad952c3b2df8bc7161deb9f9127"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#93f9538f37bfc3bba040d658fa2847a6">GenActionLists</a> (const int action_list_count=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a block of empty action lists.  <a href="#93f9538f37bfc3bba040d658fa2847a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#ec2d30f3336b2be2ab34ba3cccc55d53">NewActionList</a> (const int action_list_num)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin the creation of the specified action list.  <a href="#ec2d30f3336b2be2ab34ba3cccc55d53"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5c9df5b59ceb6b8d8584aaafc5a0609"></a><!-- doxytag: member="PAPI::PContextActionList_t::InternalSetup" ref="a5c9df5b59ceb6b8d8584aaafc5a0609" args="(PInternalState_t *Sr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>InternalSetup</b> (PInternalState_t *Sr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ec07405858c7cb91cb73340af7c95ca"></a><!-- doxytag: member="PAPI::PContextActionList_t::getInternalState" ref="0ec07405858c7cb91cb73340af7c95ca" args="() const " -->
PInternalState_t *&nbsp;</td><td class="memItemRight" valign="bottom"><b>getInternalState</b> () const </td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fdd40ca265daaa994d67e635ae63682c"></a><!-- doxytag: member="PAPI::PContextActionList_t::PS" ref="fdd40ca265daaa994d67e635ae63682c" args="" -->
PInternalState_t *&nbsp;</td><td class="memItemRight" valign="bottom"><b>PS</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Action List Calls. 
<p>
These calls create and operate on action lists, which are scripts of many actions to be applied together as a block to the current particle group. An empty action list is first created using <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#93f9538f37bfc3bba040d658fa2847a6" title="Generate a block of empty action lists.">GenActionLists()</a>, and is then filled or compiled by calling <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#ec2d30f3336b2be2ab34ba3cccc55d53" title="Begin the creation of the specified action list.">NewActionList()</a>, then calling Actions, then calling <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#f0ffaad952c3b2df8bc7161deb9f9127" title="End the creation of a new action list.">EndActionList()</a>. Once the action list is filled, it is run via <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#1fd276780b4ea073d187576f2459e1b4" title="Execute the specified action list on the current particle group.">CallActionList()</a>. Thus, an action list is sort of a higher-level action. Complex behaviors can be stored in an action list and then called later, even as part of another action list. Action lists cannot be edited. They can only be created or destroyed. To destroy an action list, call <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#bef97a9286180f1e53cb81a5c17e6205" title="Delete one or more consecutive action lists.">DeleteActionLists()</a>.<p>
When in immediate mode (not creating or calling an action list), particles are created with attributes from the current state. However, when particles are created within a <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#ec2d30f3336b2be2ab34ba3cccc55d53" title="Begin the creation of the specified action list.">NewActionList()</a> / <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#f0ffaad952c3b2df8bc7161deb9f9127" title="End the creation of a new action list.">EndActionList()</a> block, they will receive attributes from the state that was current when the action list was created (unlike OpenGL).<p>
The time step length, dt, uses the value that is current when <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#1fd276780b4ea073d187576f2459e1b4" title="Execute the specified action list on the current particle group.">CallActionList()</a> is executed, not the value of dt when the action list was created. This allows dt to be modified without recompiling action lists. Maybe this isn't a good idea. If it should be the other way in the future, let me know. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1fd276780b4ea073d187576f2459e1b4"></a><!-- doxytag: member="PAPI::PContextActionList_t::CallActionList" ref="1fd276780b4ea073d187576f2459e1b4" args="(const int action_list_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CallActionList           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>action_list_num</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute the specified action list on the current particle group. 
<p>
Call the action functions as specified when this action list was created with <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#ec2d30f3336b2be2ab34ba3cccc55d53" title="Begin the creation of the specified action list.">NewActionList()</a>. The actions are executed with the state values in effect when the action list was created, except the context's current value of dt is used, not the value of dt when the list was created.<p>
<a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#1fd276780b4ea073d187576f2459e1b4" title="Execute the specified action list on the current particle group.">CallActionList()</a> is the only function other than actions that can be stored in an action list. This allows action lists to become atomic operations in more complex action lists. When calling <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#1fd276780b4ea073d187576f2459e1b4" title="Execute the specified action list on the current particle group.">CallActionList()</a> during the creation of a new action list, action_list_num does not need to indicate an existing action list.<p>
It is an error for action_list_num to not indicate an existing (generated) action list. 
</div>
</div><p>
<a class="anchor" name="bef97a9286180f1e53cb81a5c17e6205"></a><!-- doxytag: member="PAPI::PContextActionList_t::DeleteActionLists" ref="bef97a9286180f1e53cb81a5c17e6205" args="(const int action_list_num, const int action_list_count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeleteActionLists           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>action_list_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>action_list_count</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete one or more consecutive action lists. 
<p>
Deletes action_list_count action lists, with action_list_num being the list number of the first one. The lists must be numbered sequentially, and must all exist. This removes the specified action lists from existence. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>action_list_num</em>&nbsp;</td><td>The handle of the first action list to delete </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action_list_count</em>&nbsp;</td><td>How many action lists to delete </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f0ffaad952c3b2df8bc7161deb9f9127"></a><!-- doxytag: member="PAPI::PContextActionList_t::EndActionList" ref="f0ffaad952c3b2df8bc7161deb9f9127" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EndActionList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End the creation of a new action list. 
<p>
Obviously, it is an error to call <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#f0ffaad952c3b2df8bc7161deb9f9127" title="End the creation of a new action list.">EndActionList()</a> without a corresponding call to <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#ec2d30f3336b2be2ab34ba3cccc55d53" title="Begin the creation of the specified action list.">NewActionList()</a>. 
</div>
</div><p>
<a class="anchor" name="93f9538f37bfc3bba040d658fa2847a6"></a><!-- doxytag: member="PAPI::PContextActionList_t::GenActionLists" ref="93f9538f37bfc3bba040d658fa2847a6" args="(const int action_list_count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GenActionLists           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>action_list_count</em> = <code>1</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a block of empty action lists. 
<p>
Returns the action list number of the first allocated list. All list numbers are in sequential order starting with the first list. Valid action list numbers are non-negative. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>action_list_count</em>&nbsp;</td><td>How many action lists to create </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ec2d30f3336b2be2ab34ba3cccc55d53"></a><!-- doxytag: member="PAPI::PContextActionList_t::NewActionList" ref="ec2d30f3336b2be2ab34ba3cccc55d53" args="(const int action_list_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewActionList           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>action_list_num</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin the creation of the specified action list. 
<p>
The action_list_num must have already been generated using GenActionLists. Most calls other than actions and state setting calls cannot be made between a call to <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#ec2d30f3336b2be2ab34ba3cccc55d53" title="Begin the creation of the specified action list.">NewActionList()</a> and the corresponding call to <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#f0ffaad952c3b2df8bc7161deb9f9127" title="End the creation of a new action list.">EndActionList()</a>. If called on an action list that has previously been defined, the previous contents of the action list are destroyed and the action list will be created anew. This is as with glNewActionList() in OpenGL. 
</div>
</div><p>
<a class="anchor" name="7795db5cf91fd9fb837a83054cfe96c3"></a><!-- doxytag: member="PAPI::PContextActionList_t::Seed" ref="7795db5cf91fd9fb837a83054cfe96c3" args="(const unsigned int seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Seed           </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>seed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the random number seed. 
<p>
The Particle API uses a pseudo-random number generator. The returned number is a function of the numbers already returned. If you start two threads, each with a <a class="el" href="class_p_a_p_i_1_1_particle_context__t.html" title="The Particle System API - Your app should have one of these.">ParticleContext_t</a> they will both generate the same particles if given the same commands. If this is not desired, call <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#7795db5cf91fd9fb837a83054cfe96c3" title="Set the random number seed.">Seed()</a> on both of them with different seed values. The API currently uses the C standard library random number generator, whose state is per-thread, so all contexts in the thread share the same random number seed. 
</div>
</div><p>
<a class="anchor" name="0330f623cbd0686e4fd84abe6f2a3828"></a><!-- doxytag: member="PAPI::PContextActionList_t::TimeStep" ref="0330f623cbd0686e4fd84abe6f2a3828" args="(const float new_dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimeStep           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>new_dt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify the time step length. 
<p>
The Particle System API uses a discrete time approximation to all actions. This means that actions are applied to the particles at a particular instant in time as if the action's effect accumulated over a small time interval, dt, with the world being constant over the interval. The clock is then "ticked" by the length of the interval and the actions can then be reapplied with the particles having their updated values. This is the standard method of doing almost all time-varying simulations in computer science.<p>
How does the time step, dt, relate to the application's frame rate? The easiest method is to apply the actions once per frame. If the application prefers to keep time in terms of seconds, dt can be set to (1 / frames_per_second). But more often, it is easier for a time unit to be one frame instead of one second. In this case, dt should be 1.0, which is the default.<p>
For higher quality, the application can apply particle actions more than once per frame. This provides smoother, more realistic results in many subtle ways. Suppose the application wanted to compute three animation steps for each rendered frame. Set dt to 1/3 its previous value using <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#0330f623cbd0686e4fd84abe6f2a3828" title="Specify the time step length.">TimeStep()</a>, then loop three times over all the action code that gets executed per frame, including the calls to Move. If using action lists, this can be simply a loop over the <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#1fd276780b4ea073d187576f2459e1b4" title="Execute the specified action list on the current particle group.">CallActionList()</a> call. The run-time results should be about the same, but with fewer discrete approximation artifacts. Depending on how much non-particle work is done per frame, increasing the number of time steps per frame may or may not affect the frame rate very much.<p>
In terms of numerical integration, particle actions can be thought of as the first derivative of unknown functions dictating the particle attributes (such as position) over time. In order to compute the particle attributes these derivative functions must be integrated. Since closed form integration doesn't make sense for most actions, Euler's method is used instead. Euler's method is simply the method just described – the evaluation of the derivative functions at a particular time and then incrementing the current particle values by these derivative results times dt. In Euler's method, the smaller the dt, the more accurate the results.<p>
Unlike with other state setting calls, action lists execute using the current dt value set by <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#0330f623cbd0686e4fd84abe6f2a3828" title="Specify the time step length.">TimeStep()</a>, rather than the time step value that was current when the action list was created. Making action lists independent of time step size allows the time step to be changed without recompiling the action list.<p>
In general, it is folly to call <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#0330f623cbd0686e4fd84abe6f2a3828" title="Specify the time step length.">TimeStep()</a> in between other actions of a simulation frame. For example, calling Bounce(); <a class="el" href="class_p_a_p_i_1_1_p_context_action_list__t.html#0330f623cbd0686e4fd84abe6f2a3828" title="Specify the time step length.">TimeStep()</a>; Move(); can cause cause particles to pass through the bounce domain instead of bouncing off it. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Dec 30 11:28:40 2008 for ParticleAPI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
