<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ParticleAPI: PContextActions_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_p_a_p_i.html">PAPI</a>::<a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html">PContextActions_t</a>
  </div>
</div>
<div class="contents">
<h1>PContextActions_t Class Reference</h1><!-- doxytag: class="PAPI::PContextActions_t" -->This class contains the actual Action API calls.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="p_a_p_i_8h-source.html">pAPI.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PContextActions_t:</div>
<div class="dynsection">

<p><center><img src="class_p_a_p_i_1_1_p_context_actions__t.png" usemap="#PContextActions_t_map" border="0" alt=""></center>
<map name="PContextActions_t_map">
<area href="class_p_a_p_i_1_1_particle_context__t.html" alt="ParticleContext_t" shape="rect" coords="0,56,114,80">
</map>
</div>

<p>
<a href="class_p_a_p_i_1_1_p_context_actions__t-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#2787653ada08d92a3c7fc7c86f44ff3f">Avoid</a> (float magnitude, const float epsilon, const float look_ahead, const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;dom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Steer particles away from a domain of space.  <a href="#2787653ada08d92a3c7fc7c86f44ff3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#51af31703c6bc2c58664a36907d770bf">Bounce</a> (float friction, const float resilience, const float cutoff, const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;dom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bounce particles off an object defined by a domain.  <a href="#51af31703c6bc2c58664a36907d770bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#3160d5595357cbb1ade8beb5797cec08">Callback</a> (<a class="el" href="namespace_p_a_p_i.html#44ec24ae3e34ac482ea4dfcdf9fdd6c1">P_PARTICLE_CALLBACK</a> callback, puint64 call_data=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call an arbitrary user-provided function on each particle in the group.  <a href="#3160d5595357cbb1ade8beb5797cec08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#1a1a93d1de65368340495256eac06309">CopyVertexB</a> (const bool copy_pos=true, const bool copy_vel=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the secondary position and velocity from current.  <a href="#1a1a93d1de65368340495256eac06309"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#45c603f5d694fa713cf899bd7f345a61">Damping</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;damping, const float vlow=0.0f, const float vhigh=P_MAXFLOAT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simulate air by dampening particle velocities.  <a href="#45c603f5d694fa713cf899bd7f345a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#bc3ba86037ad03977193c72cb3002b5b">RotDamping</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;damping, const float vlow=0.0f, const float vhigh=P_MAXFLOAT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simulate air by dampening rotational velocities.  <a href="#bc3ba86037ad03977193c72cb3002b5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#a38e3c026791173cb8542eed1b2dea7d">Explosion</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;center, const float radius, const float magnitude, const float sigma, const float epsilon=<a class="el" href="namespace_p_a_p_i.html#cdfcf7e535bc26fd322ed304b82d7242">P_EPS</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exert force on each particle away from explosion center.  <a href="#a38e3c026791173cb8542eed1b2dea7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#e1cb64b2a8d902681ffbe36c4fc98d27">Follow</a> (float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accelerate toward the next particle in the list.  <a href="#e1cb64b2a8d902681ffbe36c4fc98d27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#d218927aef97bb32de9ad91b3b984670">Gravitate</a> (const float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accelerate each particle toward each other particle.  <a href="#d218927aef97bb32de9ad91b3b984670"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#fd33f95bbc38e128ccae51a658321be3">Gravity</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;dir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accelerate particles in the given direction.  <a href="#fd33f95bbc38e128ccae51a658321be3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#bb0713d6237d773f42318465997d9bfe">Jet</a> (const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;dom, const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;acc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For particles in the domain of influence, accelerate them with a domain.  <a href="#bb0713d6237d773f42318465997d9bfe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#0f8cb1fad158acfe72d21f1f1a89f133">KillOld</a> (const float age_limit, const bool kill_less_than=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get rid of older particles.  <a href="#0f8cb1fad158acfe72d21f1f1a89f133"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#ddc3f942411f85b8b6863598fd0c5b9a">MatchVelocity</a> (const float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify each particle’s velocity to be similar to that of its neighbors.  <a href="#ddc3f942411f85b8b6863598fd0c5b9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#c5b174c7690e240927449881ac8f91b9">MatchRotVelocity</a> (const float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify each particle’s rotational velocity to be similar to that of its neighbors.  <a href="#c5b174c7690e240927449881ac8f91b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#7de312bfa9e8404014ff99f15170a5f1">Move</a> (const bool move_velocity=true, const bool move_rotational_velocity=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply the particles' velocities to their positions, and age the particles.  <a href="#7de312bfa9e8404014ff99f15170a5f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#6df7e64a6d81a95605727fc5e3f04683">OrbitLine</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;p, const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;axis, const float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accelerate particles toward the closest point on the given line.  <a href="#6df7e64a6d81a95605727fc5e3f04683"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#69d4c0b9891b63db44fe94afc7fd7da8">OrbitPoint</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;center, const float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accelerate particles toward the given center point.  <a href="#69d4c0b9891b63db44fe94afc7fd7da8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#16e76da8909decb2dc4f5c1f860844bb">RandomAccel</a> (const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;dom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accelerate particles in random directions.  <a href="#16e76da8909decb2dc4f5c1f860844bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#021a9a09a3c97943d52b78b77218037f">RandomDisplace</a> (const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;dom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Immediately displace position by a random amount.  <a href="#021a9a09a3c97943d52b78b77218037f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#b921ac9014746b5ded21bdd6929f28cb">RandomVelocity</a> (const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;dom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace particle velocity with a random velocity.  <a href="#b921ac9014746b5ded21bdd6929f28cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#3ca5a17b549add57f4159412509386ea">RandomRotVelocity</a> (const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;dom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Immediately assign a random rotational velocity.  <a href="#3ca5a17b549add57f4159412509386ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#3b7614b53704335235cbfca6e60d5d42">Restore</a> (const float time, const bool vel=true, const bool rvel=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Over time, restore particles to their target positionB and upB.  <a href="#3b7614b53704335235cbfca6e60d5d42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#ba6ace78eb285981979afbab17b06f01">Sink</a> (const bool kill_inside, const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;dom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill particles that have positions on wrong side of the specified domain.  <a href="#ba6ace78eb285981979afbab17b06f01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#1fc7fae32d2fa6db6dfc47bc72e7f40d">SinkVelocity</a> (const bool kill_inside, const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;dom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill particles that have velocities on wrong side of the specified domain.  <a href="#1fc7fae32d2fa6db6dfc47bc72e7f40d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#81ebb298f0b2879aa54fca390c5bbe2e">Sort</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;eye, const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;look, const bool front_to_back=false, const bool clamp_negative=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort the particles by their projection onto the look vector.  <a href="#81ebb298f0b2879aa54fca390c5bbe2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#d06e3e59d48e0aba7a0637ee1ad9c30e">Source</a> (const float particle_rate, const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;dom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add particles with positions in the specified domain.  <a href="#d06e3e59d48e0aba7a0637ee1ad9c30e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#c62277d6a6f81f68620690fbc280fa9c">SpeedLimit</a> (const float min_speed, const float max_speed=<a class="el" href="namespace_p_a_p_i.html#37212c76051870544901840b9a94a0c8">P_MAXFLOAT</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clamp particle velocities to the given range.  <a href="#c62277d6a6f81f68620690fbc280fa9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#1e413fdc19c928d6ff41fb5a3a71b3bd">TargetColor</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;color, const float alpha, const float scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change color of all particles toward the specified color.  <a href="#1e413fdc19c928d6ff41fb5a3a71b3bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#f98e7e68da84ef78e82343db8c7d6c54">TargetSize</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;size, const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change sizes of all particles toward the specified size.  <a href="#f98e7e68da84ef78e82343db8c7d6c54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#9b2d572a5da762693c7c55d051f77668">TargetVelocity</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;vel, const float scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change velocity of all particles toward the specified velocity.  <a href="#9b2d572a5da762693c7c55d051f77668"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#e7cd7f494f1d306d7660ba54f0cebec7">TargetRotVelocity</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;rvel, const float scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change rotational velocity of all particles toward the specified rotational velocity.  <a href="#e7cd7f494f1d306d7660ba54f0cebec7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#c70b322e7444ae5df26e1aa10430d22d">Vertex</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;v, puint64 data=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a single particle at the specified location.  <a href="#c70b322e7444ae5df26e1aa10430d22d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#f1cdf3dd1dbde708278ec0bf08081bfd">Vortex</a> (const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;center, const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;axis, const float tightnessExponent, const float max_radius, const float inSpeed, const float upSpeed, const float aroundSpeed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accelerate particles in a vortex-like way.  <a href="#f1cdf3dd1dbde708278ec0bf08081bfd"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5c9df5b59ceb6b8d8584aaafc5a0609"></a><!-- doxytag: member="PAPI::PContextActions_t::InternalSetup" ref="a5c9df5b59ceb6b8d8584aaafc5a0609" args="(PInternalState_t *Sr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>InternalSetup</b> (PInternalState_t *Sr)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fdd40ca265daaa994d67e635ae63682c"></a><!-- doxytag: member="PAPI::PContextActions_t::PS" ref="fdd40ca265daaa994d67e635ae63682c" args="" -->
PInternalState_t *&nbsp;</td><td class="memItemRight" valign="bottom"><b>PS</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class contains the actual Action API calls. 
<p>
Actions modify the position, color, velocity, size, age, and other attributes of particles. All actions apply to the current particle group, as set by CurrentGroup(). Some actions will add particles to or delete them from the particle group, and others will modify the particles in other ways. Typically, a series of actions will be applied to each particle group once (or more) per rendered frame.<p>
Remember that the amount of effect of an action call depends on the time step size, dt, as set by TimeStep. See TimeStep() for an explanation of time steps.<p>
Some functions have parameters with a default value of the constant P_EPS. P_EPS is a very small floating point constant that is most often used as the default value of the epsilon parameter to actions whose influence on a particle is relative to the inverse square of its distance from something. If that distance is very small, the amount of influence approaches infinity. Since all actions are computed using Euler's method, this can cause unsatisfying results in which particles are accelerated way too much. So this epsilon parameter is added to the distance before taking its inverse square, thus keeping the acceleration within reasonable limits. By varying epsilon, you specify what is reasonable. Larger epsilon make particles accelerate less. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2787653ada08d92a3c7fc7c86f44ff3f"></a><!-- doxytag: member="PAPI::PContextActions_t::Avoid" ref="2787653ada08d92a3c7fc7c86f44ff3f" args="(float magnitude, const float epsilon, const float look_ahead, const pDomain &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>look_ahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Steer particles away from a domain of space. 
<p>
Particles are tested to see whether they will pass from being outside the specified domain to being inside it within look_ahead time units from now if the next <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#7de312bfa9e8404014ff99f15170a5f1" title="Apply the particles&#39; velocities to their positions, and age the particles.">Move()</a> action were to occur now. The specific direction and amount of turn is dependent on the kind of domain being avoided.<p>
At present the only domains for which <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#2787653ada08d92a3c7fc7c86f44ff3f" title="Steer particles away from a domain of space.">Avoid()</a> is implemented are <a class="el" href="class_p_a_p_i_1_1_p_d_sphere.html" title="Sphere.">PDSphere</a>, <a class="el" href="class_p_a_p_i_1_1_p_d_rectangle.html" title="Rhombus-shaped planar region.">PDRectangle</a>, <a class="el" href="class_p_a_p_i_1_1_p_d_triangle.html" title="A Triangle.">PDTriangle</a>, <a class="el" href="class_p_a_p_i_1_1_p_d_disc.html" title="Arbitrarily-oriented disc.">PDDisc</a> and <a class="el" href="class_p_a_p_i_1_1_p_d_plane.html" title="Arbitrarily-oriented plane.">PDPlane</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>magnitude</em>&nbsp;</td><td>how drastically the particle velocities are modified to avoid the obstacle at each time step. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The amount of acceleration falls off inversely with the squared distance to the edge of the domain. But when that distance is small, the acceleration would be infinite, so epsilon is always added to the distance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>look_ahead</em>&nbsp;</td><td>how far forward along the velocity vector to look for the obstacle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dom</em>&nbsp;</td><td>the space to avoid </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="51af31703c6bc2c58664a36907d770bf"></a><!-- doxytag: member="PAPI::PContextActions_t::Bounce" ref="51af31703c6bc2c58664a36907d770bf" args="(float friction, const float resilience, const float cutoff, const pDomain &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bounce           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>friction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>resilience</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bounce particles off an object defined by a domain. 
<p>
Particles are tested to see whether they will pass from being outside the specified domain to being inside it if the next <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#7de312bfa9e8404014ff99f15170a5f1" title="Apply the particles&#39; velocities to their positions, and age the particles.">Move()</a> action were to occur now. If they would pass through the surface of the domain, they are instead bounced off it. That is, their velocity vector is decomposed into components normal to the surface and tangent to the surface. The direction of the normal component is reversed, and friction, resilience and cutoff are applied to the components. They are then recomposed into a new velocity heading away from the surface.<p>
Since particles are tested to see whether they would pass through the domain if <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#7de312bfa9e8404014ff99f15170a5f1" title="Apply the particles&#39; velocities to their positions, and age the particles.">Move()</a> were called now, it is best to have <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#51af31703c6bc2c58664a36907d770bf" title="Bounce particles off an object defined by a domain.">Bounce()</a> be the last action that modifies a particle's velocity before calling <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#7de312bfa9e8404014ff99f15170a5f1" title="Apply the particles&#39; velocities to their positions, and age the particles.">Move()</a>. Also, actions such as <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#021a9a09a3c97943d52b78b77218037f" title="Immediately displace position by a random amount.">RandomDisplace()</a> that modify a particle's position directly, rather than modifying its velocity vector, may yield unsatisfying results when used with <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#51af31703c6bc2c58664a36907d770bf" title="Bounce particles off an object defined by a domain.">Bounce()</a>.<p>
At present the only domains for which <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#51af31703c6bc2c58664a36907d770bf" title="Bounce particles off an object defined by a domain.">Bounce()</a> is implemented are <a class="el" href="class_p_a_p_i_1_1_p_d_sphere.html" title="Sphere.">PDSphere</a>, <a class="el" href="class_p_a_p_i_1_1_p_d_rectangle.html" title="Rhombus-shaped planar region.">PDRectangle</a>, <a class="el" href="class_p_a_p_i_1_1_p_d_triangle.html" title="A Triangle.">PDTriangle</a>, <a class="el" href="class_p_a_p_i_1_1_p_d_disc.html" title="Arbitrarily-oriented disc.">PDDisc</a> and <a class="el" href="class_p_a_p_i_1_1_p_d_plane.html" title="Arbitrarily-oriented plane.">PDPlane</a>. For spheres, the particle bounces off either the inside or the outside of the sphere. For planes, triangles and discs, the particles bounce off either side of the surface. For rectangles, particles bounce off either side of the diamond-shaped patch whose corners are o, o+u, o+u+v, and o+v. See the documentation on domains for further explanation.<p>
<a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#51af31703c6bc2c58664a36907d770bf" title="Bounce particles off an object defined by a domain.">Bounce()</a> doesn't work correctly with small time step sizes for particles sliding along a surface. The friction and resilience parameters should not be scaled by dt, since a bounce happens instantaneously. On the other hand, they should be scaled by dt because particles sliding along a surface will hit more often if dt is smaller. Adjust these parameters manually when you change dt. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>friction</em>&nbsp;</td><td>The tangential component of the outgoing velocity vector is scaled by (1 - friction). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resilience</em>&nbsp;</td><td>The normal component of the outgoing velocity vector is scaled by resilience. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cutoff</em>&nbsp;</td><td>Only apply friction if the outgoing tangential velocity is greater than cutoff. This can allow particles to glide smoothly along a surface without sticking. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dom</em>&nbsp;</td><td>Bounce off the surface of this domain. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3160d5595357cbb1ade8beb5797cec08"></a><!-- doxytag: member="PAPI::PContextActions_t::Callback" ref="3160d5595357cbb1ade8beb5797cec08" args="(P_PARTICLE_CALLBACK callback, puint64 call_data=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Callback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_p_a_p_i.html#44ec24ae3e34ac482ea4dfcdf9fdd6c1">P_PARTICLE_CALLBACK</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">puint64&nbsp;</td>
          <td class="paramname"> <em>call_data</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call an arbitrary user-provided function on each particle in the group. 
<p>
The function will receive both your call data and the full Particle_t struct, which contains per-particle user data. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Pointer to function of yours to call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>call_data</em>&nbsp;</td><td>Arbitrary data of yours to pass into your function </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1a1a93d1de65368340495256eac06309"></a><!-- doxytag: member="PAPI::PContextActions_t::CopyVertexB" ref="1a1a93d1de65368340495256eac06309" args="(const bool copy_pos=true, const bool copy_vel=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CopyVertexB           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>copy_pos</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>copy_vel</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the secondary position and velocity from current. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copy_pos</em>&nbsp;</td><td>If true, sets the PositionB of each particle to the current position of that particle. This makes each particle remember this position so it can later return to it using the <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#3b7614b53704335235cbfca6e60d5d42" title="Over time, restore particles to their target positionB and upB.">Restore()</a> action. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_vel</em>&nbsp;</td><td>If true, sets the velocityB of each particle to the current velocity of that particle. This can be useful for computing the orientation of the particle by copying a particle's velocity at the beginning of each time step. Then when drawing a particle, the cross-product velocity and velocityB yields a tangent vector. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="45c603f5d694fa713cf899bd7f345a61"></a><!-- doxytag: member="PAPI::PContextActions_t::Damping" ref="45c603f5d694fa713cf899bd7f345a61" args="(const pVec &amp;damping, const float vlow=0.0f, const float vhigh=P_MAXFLOAT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Damping           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>damping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>vlow</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>vhigh</em> = <code><a class="el" href="namespace_p_a_p_i.html#37212c76051870544901840b9a94a0c8">P_MAXFLOAT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simulate air by dampening particle velocities. 
<p>
If a particle's velocity magnitude is within vlow and vhigh, then multiply each component of the velocity by the respective damping constant. Typically, the three components of damping will have the same value.<p>
There are no bounds on the damping constants. Thus, by giving values greater than 1.0 they may be used to speed up particles instead of slow them down. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>damping</em>&nbsp;</td><td>Component-wise multiply this vector by the velocity vector </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a38e3c026791173cb8542eed1b2dea7d"></a><!-- doxytag: member="PAPI::PContextActions_t::Explosion" ref="a38e3c026791173cb8542eed1b2dea7d" args="(const pVec &amp;center, const float radius, const float magnitude, const float sigma, const float epsilon=P_EPS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Explosion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>epsilon</em> = <code><a class="el" href="namespace_p_a_p_i.html#cdfcf7e535bc26fd322ed304b82d7242">P_EPS</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exert force on each particle away from explosion center. 
<p>
Causes an explosion by accelerating all particles away from the center. Particles are accelerated away from the center by an amount proportional to magnitude. The shock wave of the explosion has a gaussian magnitude. The peak of the wave front travels spherically outward from the center at the specified velocity. So at a given time step, particles at a distance (velocity * age) from center will receive the most acceleration, and particles not at the peak of the shock wave will receive a lesser outward acceleration.<p>
radius is the current radius of the explosion wave's peak. It is up to the application to increment the radius for each call to <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#a38e3c026791173cb8542eed1b2dea7d" title="Exert force on each particle away from explosion center.">Explosion()</a>. For <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#a38e3c026791173cb8542eed1b2dea7d" title="Exert force on each particle away from explosion center.">Explosion()</a> calls in action lists, this means you will need to recreate the action list each time step.<p>
You can set up a standing wave by not incrementing the radius. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>center</em>&nbsp;</td><td>center point of shock wave </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>current radius of wave peak </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>magnitude</em>&nbsp;</td><td>scales the acceleration applied to particles </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma</em>&nbsp;</td><td>standard deviation of the gaussian; the sharpness or broadness of the strength of the wave. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The amount of acceleration falls off inversely with the squared distance to the edge of the domain. But when that distance is small, the acceleration would be infinite, so epsilon is always added to the distance. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e1cb64b2a8d902681ffbe36c4fc98d27"></a><!-- doxytag: member="PAPI::PContextActions_t::Follow" ref="e1cb64b2a8d902681ffbe36c4fc98d27" args="(float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Follow           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>magnitude</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>epsilon</em> = <code><a class="el" href="namespace_p_a_p_i.html#cdfcf7e535bc26fd322ed304b82d7242">P_EPS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>max_radius</em> = <code><a class="el" href="namespace_p_a_p_i.html#37212c76051870544901840b9a94a0c8">P_MAXFLOAT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accelerate toward the next particle in the list. 
<p>
This allows snaky effects where the particles follow each other. Each particle is accelerated toward the next particle in the group. The <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#e1cb64b2a8d902681ffbe36c4fc98d27" title="Accelerate toward the next particle in the list.">Follow()</a> action does not affect the last particle in the group. This allows controlled effects where the last particle in the group is killed after each time step and replaced by a new particle at a slightly different position. See <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#0f8cb1fad158acfe72d21f1f1a89f133" title="Get rid of older particles.">KillOld()</a> to learn how to kill the last particle in the group after each step. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>magnitude</em>&nbsp;</td><td>scales each particle's acceleration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The amount of acceleration falls off inversely with the squared distance to the edge of the domain. But when that distance is small, the acceleration would be infinite, so epsilon is always added to the distance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_radius</em>&nbsp;</td><td>defines the sphere of influence of this action. No particle further than max_radius from its predecessor is affected. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d218927aef97bb32de9ad91b3b984670"></a><!-- doxytag: member="PAPI::PContextActions_t::Gravitate" ref="d218927aef97bb32de9ad91b3b984670" args="(const float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gravitate           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>magnitude</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>epsilon</em> = <code><a class="el" href="namespace_p_a_p_i.html#cdfcf7e535bc26fd322ed304b82d7242">P_EPS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>max_radius</em> = <code><a class="el" href="namespace_p_a_p_i.html#37212c76051870544901840b9a94a0c8">P_MAXFLOAT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accelerate each particle toward each other particle. 
<p>
Each particle is accelerated toward each other particle. This action is more computationally intensive than the others are because each particle is affected by each other particle. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>magnitude</em>&nbsp;</td><td>scales each particle's acceleration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The amount of acceleration falls off inversely with the squared distance to the edge of the domain. But when that distance is small, the acceleration would be infinite, so epsilon is always added to the distance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_radius</em>&nbsp;</td><td>defines the sphere of influence of this action. No particle further than max_radius from another particle is affected. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fd33f95bbc38e128ccae51a658321be3"></a><!-- doxytag: member="PAPI::PContextActions_t::Gravity" ref="fd33f95bbc38e128ccae51a658321be3" args="(const pVec &amp;dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gravity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dir</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accelerate particles in the given direction. 
<p>
The gravity acceleration vector is simply added to the velocity vector of each particle at each time step. The magnitude of the gravity vector is the acceleration due to gravity. 
</div>
</div><p>
<a class="anchor" name="bb0713d6237d773f42318465997d9bfe"></a><!-- doxytag: member="PAPI::PContextActions_t::Jet" ref="bb0713d6237d773f42318465997d9bfe" args="(const pDomain &amp;dom, const pDomain &amp;acc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Jet           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>acc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For particles in the domain of influence, accelerate them with a domain. 
<p>
For each particle within the jet's domain of influence, dom, <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#bb0713d6237d773f42318465997d9bfe" title="For particles in the domain of influence, accelerate them with a domain.">Jet()</a> chooses an acceleration vector from the domain acc and applies it to the particle's velocity. acceleration vector comes from this domain <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dom</em>&nbsp;</td><td>apply jet to particles in this domain </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0f8cb1fad158acfe72d21f1f1a89f133"></a><!-- doxytag: member="PAPI::PContextActions_t::KillOld" ref="0f8cb1fad158acfe72d21f1f1a89f133" args="(const float age_limit, const bool kill_less_than=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KillOld           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>age_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>kill_less_than</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get rid of older particles. 
<p>
Removes all particles older than age_limit. But if kill_less_than is true, it instead removes all particles newer than age_limit. age_limit is not clamped, so negative values are ok. This can be used in conjunction with StartingAge(-n) to create and then kill a particular set of particles.<p>
In order to kill a particular particle, set StartingAge() to a number that will never be a typical age for any other particle in the group, for example -1.0. Then emit the particle using <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#d06e3e59d48e0aba7a0637ee1ad9c30e" title="Add particles with positions in the specified domain.">Source()</a> or <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#c70b322e7444ae5df26e1aa10430d22d" title="Add a single particle at the specified location.">Vertex()</a>. Then do the rest of the particle actions and finally call KillOld(-0.9, true) to kill the special particle because it is the only one with an age less than -0.9. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>kill_less_than</em>&nbsp;</td><td>true to kill particles younger than age_limit </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c5b174c7690e240927449881ac8f91b9"></a><!-- doxytag: member="PAPI::PContextActions_t::MatchRotVelocity" ref="c5b174c7690e240927449881ac8f91b9" args="(const float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatchRotVelocity           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>magnitude</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>epsilon</em> = <code><a class="el" href="namespace_p_a_p_i.html#cdfcf7e535bc26fd322ed304b82d7242">P_EPS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>max_radius</em> = <code><a class="el" href="namespace_p_a_p_i.html#37212c76051870544901840b9a94a0c8">P_MAXFLOAT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modify each particle’s rotational velocity to be similar to that of its neighbors. 
<p>
Each particle is accelerated toward the weighted mean of the rotational velocities of the other particles in the group.<p>
Using an epsilon similar in size to magnitude can increase the range of influence of nearby particles on this particle. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>magnitude</em>&nbsp;</td><td>scales each particle's acceleration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The amount of acceleration falls off inversely with the squared distance to the edge of the domain. But when that distance is small, the acceleration would be infinite, so epsilon is always added to the distance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_radius</em>&nbsp;</td><td>defines the sphere of influence of this action. No particle further than max_radius from another particle is affected. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ddc3f942411f85b8b6863598fd0c5b9a"></a><!-- doxytag: member="PAPI::PContextActions_t::MatchVelocity" ref="ddc3f942411f85b8b6863598fd0c5b9a" args="(const float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatchVelocity           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>magnitude</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>epsilon</em> = <code><a class="el" href="namespace_p_a_p_i.html#cdfcf7e535bc26fd322ed304b82d7242">P_EPS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>max_radius</em> = <code><a class="el" href="namespace_p_a_p_i.html#37212c76051870544901840b9a94a0c8">P_MAXFLOAT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modify each particle’s velocity to be similar to that of its neighbors. 
<p>
Each particle is accelerated toward the weighted mean of the velocities of the other particles in the group.<p>
Using an epsilon similar in size to magnitude can increase the range of influence of nearby particles on this particle. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>magnitude</em>&nbsp;</td><td>scales each particle's acceleration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The amount of acceleration falls off inversely with the squared distance to the edge of the domain. But when that distance is small, the acceleration would be infinite, so epsilon is always added to the distance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_radius</em>&nbsp;</td><td>defines the sphere of influence of this action. No particle further than max_radius from another particle is affected. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7de312bfa9e8404014ff99f15170a5f1"></a><!-- doxytag: member="PAPI::PContextActions_t::Move" ref="7de312bfa9e8404014ff99f15170a5f1" args="(const bool move_velocity=true, const bool move_rotational_velocity=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Move           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>move_velocity</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>move_rotational_velocity</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply the particles' velocities to their positions, and age the particles. 
<p>
This action actually updates the particle positions by adding the current velocity to the current position and the current rotational velocity to the current up vector. This is typically the last particle action performed in an iteration of a particle simulation, and typically only occurs once per iteration.<p>
The velocity is multiplied by the time step length, dt, before being added to the position. This implements Euler's method of numerical integration with a constant but specifiable step size. See TimeStep() for more on varying the time step size. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>move_velocity</em>&nbsp;</td><td>apply velocity to position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>move_rotational_velocity</em>&nbsp;</td><td>apply rotational velocity to Up vector. This is an optimization. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6df7e64a6d81a95605727fc5e3f04683"></a><!-- doxytag: member="PAPI::PContextActions_t::OrbitLine" ref="6df7e64a6d81a95605727fc5e3f04683" args="(const pVec &amp;p, const pVec &amp;axis, const float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OrbitLine           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>magnitude</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>epsilon</em> = <code><a class="el" href="namespace_p_a_p_i.html#cdfcf7e535bc26fd322ed304b82d7242">P_EPS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>max_radius</em> = <code><a class="el" href="namespace_p_a_p_i.html#37212c76051870544901840b9a94a0c8">P_MAXFLOAT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accelerate particles toward the closest point on the given line. 
<p>
For each particle, this action computes the vector to the closest point on the line, and accelerates the particle in that direction. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>a point on the line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>any vector parallel to the line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>magnitude</em>&nbsp;</td><td>scales each particle's acceleration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The amount of acceleration falls off inversely with the squared distance to the edge of the domain. But when that distance is small, the acceleration would be infinite, so epsilon is always added to the distance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_radius</em>&nbsp;</td><td>defines the cylinder of influence of this action. No particle further than max_radius from the line is affected. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="69d4c0b9891b63db44fe94afc7fd7da8"></a><!-- doxytag: member="PAPI::PContextActions_t::OrbitPoint" ref="69d4c0b9891b63db44fe94afc7fd7da8" args="(const pVec &amp;center, const float magnitude=1.0f, const float epsilon=P_EPS, const float max_radius=P_MAXFLOAT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OrbitPoint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>magnitude</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>epsilon</em> = <code><a class="el" href="namespace_p_a_p_i.html#cdfcf7e535bc26fd322ed304b82d7242">P_EPS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>max_radius</em> = <code><a class="el" href="namespace_p_a_p_i.html#37212c76051870544901840b9a94a0c8">P_MAXFLOAT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accelerate particles toward the given center point. 
<p>
For each particle, this action computes the vector to the center point, and accelerates the particle in the vector direction. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>center</em>&nbsp;</td><td>accelerate toward this point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>magnitude</em>&nbsp;</td><td>scales each particle's acceleration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The amount of acceleration falls off inversely with the squared distance to the edge of the domain. But when that distance is small, the acceleration would be infinite, so epsilon is always added to the distance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_radius</em>&nbsp;</td><td>defines the sphere of influence of this action. No particle further than max_radius from the center is affected. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="16e76da8909decb2dc4f5c1f860844bb"></a><!-- doxytag: member="PAPI::PContextActions_t::RandomAccel" ref="16e76da8909decb2dc4f5c1f860844bb" args="(const pDomain &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RandomAccel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accelerate particles in random directions. 
<p>
For each particle, chooses an acceleration vector from the specified domain and adds it to the particle's velocity. Reducing the time step, dt, will make a higher probability of being near the original velocity after unit time. Smaller dt approach a normal distribution of velocity vectors instead of a square wave distribution. 
</div>
</div><p>
<a class="anchor" name="021a9a09a3c97943d52b78b77218037f"></a><!-- doxytag: member="PAPI::PContextActions_t::RandomDisplace" ref="021a9a09a3c97943d52b78b77218037f" args="(const pDomain &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RandomDisplace           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Immediately displace position by a random amount. 
<p>
Chooses a displacement vector from the specified domain and adds it to the particle's position. Reducing the time step, dt, will make a higher probability of being near the original position after unit time. Smaller dt approach a normal distribution of particle positions instead of a square wave distribution.<p>
Since this action changes particle positions, rather than changing their velocities and depending on the <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#7de312bfa9e8404014ff99f15170a5f1" title="Apply the particles&#39; velocities to their positions, and age the particles.">Move()</a> action to change the positions, unsatisfying results may occur when used with the <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#2787653ada08d92a3c7fc7c86f44ff3f" title="Steer particles away from a domain of space.">Avoid()</a> or <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#51af31703c6bc2c58664a36907d770bf" title="Bounce particles off an object defined by a domain.">Bounce()</a> actions. In particular, particles may be displaced to the opposite side of the surface without bouncing off it. 
</div>
</div><p>
<a class="anchor" name="3ca5a17b549add57f4159412509386ea"></a><!-- doxytag: member="PAPI::PContextActions_t::RandomRotVelocity" ref="3ca5a17b549add57f4159412509386ea" args="(const pDomain &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RandomRotVelocity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Immediately assign a random rotational velocity. 
<p>
For each particle, sets the particle's rotational velocity vector to a random vector in the specified domain. This function is not affected by dt. 
</div>
</div><p>
<a class="anchor" name="b921ac9014746b5ded21bdd6929f28cb"></a><!-- doxytag: member="PAPI::PContextActions_t::RandomVelocity" ref="b921ac9014746b5ded21bdd6929f28cb" args="(const pDomain &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RandomVelocity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace particle velocity with a random velocity. 
<p>
For each particle, sets the particle's velocity vector to a random vector in the specified domain. This function is not affected by dt. 
</div>
</div><p>
<a class="anchor" name="3b7614b53704335235cbfca6e60d5d42"></a><!-- doxytag: member="PAPI::PContextActions_t::Restore" ref="3b7614b53704335235cbfca6e60d5d42" args="(const float time, const bool vel=true, const bool rvel=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Restore           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>vel</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>rvel</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Over time, restore particles to their target positionB and upB. 
<p>
If vel is true, computes a new velocity for each particle that will make the particle arrive at its positionB at the specified amount of time in the future. If rvel is true, computes a new rotational velocity that moves up toward upB.<p>
The curved path that the particles take is a parametric quadratic. Once the specified amount of time has passed, <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#3b7614b53704335235cbfca6e60d5d42" title="Over time, restore particles to their target positionB and upB.">Restore()</a> instead sets position and Up to equal positionB and upB and sets velocity and rotational velocity to 0 to freeze them in place.<p>
It is the application's responsibility to decrease time_left by dt on each call. When in an action list, this means you need to recreate the action list each time step.<p>
The positionB attribute of each particle is typically the particle's position when it was created, or it can be specified within a domain. This is controlled by VertexBTracks(), and VertexB(). The positionB can be set at any time to the particle's current position using the <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#1a1a93d1de65368340495256eac06309" title="Set the secondary position and velocity from current.">CopyVertexB()</a> action.<p>
Restore(0) is the opposite of <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#1a1a93d1de65368340495256eac06309" title="Set the secondary position and velocity from current.">CopyVertexB()</a>; it sets each particle's position to be equal to its positionB. However, this has the side effect of setting each particle's velocity to 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>how long more until particles should arrive at target position and orientation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vel</em>&nbsp;</td><td>restore positions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rvel</em>&nbsp;</td><td>restore up vectors </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bc3ba86037ad03977193c72cb3002b5b"></a><!-- doxytag: member="PAPI::PContextActions_t::RotDamping" ref="bc3ba86037ad03977193c72cb3002b5b" args="(const pVec &amp;damping, const float vlow=0.0f, const float vhigh=P_MAXFLOAT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RotDamping           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>damping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>vlow</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>vhigh</em> = <code><a class="el" href="namespace_p_a_p_i.html#37212c76051870544901840b9a94a0c8">P_MAXFLOAT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simulate air by dampening rotational velocities. 
<p>
If a particle's rotational velocity magnitude is within vlow and vhigh, then multiply each component of the rotational velocity by the respective damping constant. Typically, the three components of damping will have the same value.<p>
There are no bounds on the damping constants. Thus, by giving values greater than 1.0 they may be used to speed up particles instead of slow them down. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>damping</em>&nbsp;</td><td>Component-wise multiply this vector by the rotational velocity vector </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ba6ace78eb285981979afbab17b06f01"></a><!-- doxytag: member="PAPI::PContextActions_t::Sink" ref="ba6ace78eb285981979afbab17b06f01" args="(const bool kill_inside, const pDomain &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sink           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>kill_inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Kill particles that have positions on wrong side of the specified domain. 
<p>
If kill_inside is true, deletes all particles inside the given domain. If kill_inside is false, deletes all particles outside the given domain. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>kill_inside</em>&nbsp;</td><td>true to kill particles inside the domain </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1fc7fae32d2fa6db6dfc47bc72e7f40d"></a><!-- doxytag: member="PAPI::PContextActions_t::SinkVelocity" ref="1fc7fae32d2fa6db6dfc47bc72e7f40d" args="(const bool kill_inside, const pDomain &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SinkVelocity           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>kill_inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Kill particles that have velocities on wrong side of the specified domain. 
<p>
If kill_inside is true, deletes all particles whose velocity vectors are inside the given domain. If kill_inside is false, deletes all particles whose velocity vectors are outside the given domain. This allows particles to die when they turn around, get too fast or too slow, etc. For example, use a sphere domain centered at the origin with a radius equal to the minimum velocity to kill particles that are too slow. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>kill_inside</em>&nbsp;</td><td>true to kill particles with velocities inside the domain </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="81ebb298f0b2879aa54fca390c5bbe2e"></a><!-- doxytag: member="PAPI::PContextActions_t::Sort" ref="81ebb298f0b2879aa54fca390c5bbe2e" args="(const pVec &amp;eye, const pVec &amp;look, const bool front_to_back=false, const bool clamp_negative=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sort           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>eye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>look</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>front_to_back</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>clamp_negative</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sort the particles by their projection onto the look vector. 
<p>
Many rendering systems require rendering transparent particles in back-to-front order. The ordering is defined by the eye point and the look vector. These are the same vectors you pass into gluLookAt(), for example. The vector from the eye point to each particle's position is computed, then projected onto the look vector. Particles are sorted back-to-front by the result of this dot product. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>front_to_back</em>&nbsp;</td><td>true to sort in front-to-back order instead of back-to-front </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clamp_negative</em>&nbsp;</td><td>true to set negative dot product values to zero before sorting. This speeds up sorting time. Particles behind the viewer won't be visible so their relative order doesn't matter. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d06e3e59d48e0aba7a0637ee1ad9c30e"></a><!-- doxytag: member="PAPI::PContextActions_t::Source" ref="d06e3e59d48e0aba7a0637ee1ad9c30e" args="(const float particle_rate, const pDomain &amp;dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Source           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>particle_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_domain.html">pDomain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add particles with positions in the specified domain. 
<p>
Adds new particles to the current particle group. The particle positions are chosen from the given domain. All the other particle attributes such as color and velocity are chosen according to their current domains.<p>
When the Source action is called within an action list, the particle attribute domains used are those that were current when the Source command was called within the NewActionList() / EndActionList() block instead of when CallActionList() was called. Note that this is unlike OpenGL display lists.<p>
If particle_rate / dt is not an integer then <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#d06e3e59d48e0aba7a0637ee1ad9c30e" title="Add particles with positions in the specified domain.">Source()</a> adjusts the number of particles to add during this time step so that the average number added per unit time is particle_rate.<p>
If too few particles seem to be added each frame, it is probably because the particle group is already full. If this is bad, you can grow the group using SetMaxParticles(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>particle_rate</em>&nbsp;</td><td>how many particles to add per unit time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dom</em>&nbsp;</td><td>particle positions are chosen from this domain </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c62277d6a6f81f68620690fbc280fa9c"></a><!-- doxytag: member="PAPI::PContextActions_t::SpeedLimit" ref="c62277d6a6f81f68620690fbc280fa9c" args="(const float min_speed, const float max_speed=P_MAXFLOAT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpeedLimit           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>min_speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>max_speed</em> = <code><a class="el" href="namespace_p_a_p_i.html#37212c76051870544901840b9a94a0c8">P_MAXFLOAT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clamp particle velocities to the given range. 
<p>
Computes each particle’s speed (the magnitude of its velocity vector) and if it is less than min_speed or greater than max_speed the velocity is scaled to within those bounds, while preserving the velocity vector’s direction.<p>
The vector [0,0,0] is an exception because it has no direction. Such vectors are not modified by <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#c62277d6a6f81f68620690fbc280fa9c" title="Clamp particle velocities to the given range.">SpeedLimit()</a>. 
</div>
</div><p>
<a class="anchor" name="1e413fdc19c928d6ff41fb5a3a71b3bd"></a><!-- doxytag: member="PAPI::PContextActions_t::TargetColor" ref="1e413fdc19c928d6ff41fb5a3a71b3bd" args="(const pVec &amp;color, const float alpha, const float scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TargetColor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change color of all particles toward the specified color. 
<p>
Modifies the color and alpha of each particle to be scale percent of the way closer to the specified color and alpha. scale is multiplied by dt before scaling the sizes. Thus, using smaller dt causes a slightly faster approach to the target color.<p>
This action makes all colors tend toward the specified, uniform color. The value of scale will usually be very small (less than 0.01) to yield a gradual transition. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>target color </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>target alpha value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>what percent of the way from the current color to the target color to transition in unit time </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e7cd7f494f1d306d7660ba54f0cebec7"></a><!-- doxytag: member="PAPI::PContextActions_t::TargetRotVelocity" ref="e7cd7f494f1d306d7660ba54f0cebec7" args="(const pVec &amp;rvel, const float scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TargetRotVelocity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rvel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change rotational velocity of all particles toward the specified rotational velocity. 
<p>
Modifies the rotational velocity of each particle to be scale percent of the way closer to the specified rotational velocity. This makes rotational velocities grow asymptotically closer to the given rotational velocity. scale is multiplied by dt before scaling the velocities. Thus, using smaller dt causes a slightly faster approach to the target rotational velocity.<p>
This action makes all rotational velocities tend toward the specified, uniform rotational velocity. The value of scale will usually be very small (less than 0.01) to yield a gradual transition. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rvel</em>&nbsp;</td><td>rotational velocity </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>what percent of the way from the current rotational velocity to the target rotational velocity to transition in unit time </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f98e7e68da84ef78e82343db8c7d6c54"></a><!-- doxytag: member="PAPI::PContextActions_t::TargetSize" ref="f98e7e68da84ef78e82343db8c7d6c54" args="(const pVec &amp;size, const pVec &amp;scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TargetSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change sizes of all particles toward the specified size. 
<p>
Modifies the size of each particle to be scale percent of the way closer to the specified size triple. This makes sizes grow asymptotically closer to the given size. scale is multiplied by dt before scaling the sizes. Thus, using smaller dt causes a slightly faster approach to the target size. The separate scales for each component allow only selected components to be scaled.<p>
This action makes all sizes tend toward the specified, uniform size. Future versions will have more actions that modify size. Please send me suggestions (perhaps with sample implementations).<p>
The value of scale will usually be very small (less than 0.01) to yield a gradual transition. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>target size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>what percent of the way from the current size to the target size to transition in unit time </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9b2d572a5da762693c7c55d051f77668"></a><!-- doxytag: member="PAPI::PContextActions_t::TargetVelocity" ref="9b2d572a5da762693c7c55d051f77668" args="(const pVec &amp;vel, const float scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TargetVelocity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change velocity of all particles toward the specified velocity. 
<p>
Modifies the velocity of each particle to be scale percent of the way closer to the specified velocity. This makes velocities grow asymptotically closer to the given velocity. scale is multiplied by dt before scaling the velocities. Thus, using smaller dt causes a slightly faster approach to the target velocity.<p>
This action makes all velocities tend toward the specified, uniform velocity. The value of scale will usually be very small (less than 0.01) to yield a gradual transition. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vel</em>&nbsp;</td><td>target velocity </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>what percent of the way from the current velocity to the target velocity to transition in unit time </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c70b322e7444ae5df26e1aa10430d22d"></a><!-- doxytag: member="PAPI::PContextActions_t::Vertex" ref="c70b322e7444ae5df26e1aa10430d22d" args="(const pVec &amp;v, puint64 data=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Vertex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">puint64&nbsp;</td>
          <td class="paramname"> <em>data</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a single particle at the specified location. 
<p>
This action mostly is a shorthand for Source(1, PDPoint(x, y, z)) but allows different callback data per particle.<p>
When called in immediate mode, this action uses a slightly faster method to add a single particle to the current particle group. Also when in immediate mode, exactly one particle will be added per call, instead of an average of 1 / dt particles being added. Particle attributes are chosen according to their current domains, as with Source.<p>
The user data attribute is an exception. It always takes the attribute from the optional data parameter to <a class="el" href="class_p_a_p_i_1_1_p_context_actions__t.html#c70b322e7444ae5df26e1aa10430d22d" title="Add a single particle at the specified location.">Vertex()</a>, overriding the source state value.<p>
This call is patterned after the glVertex() calls. It is useful for creating a particle group with exactly specified initial positions. For example, you can specify a geometrical model using Vertex calls, and then explode or deform it. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>position of particle to create </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>application data to be passed to the birth and death callbacks </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f1cdf3dd1dbde708278ec0bf08081bfd"></a><!-- doxytag: member="PAPI::PContextActions_t::Vortex" ref="f1cdf3dd1dbde708278ec0bf08081bfd" args="(const pVec &amp;center, const pVec &amp;axis, const float tightnessExponent, const float max_radius, const float inSpeed, const float upSpeed, const float aroundSpeed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Vortex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_a_p_i_1_1p_vec.html">pVec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>tightnessExponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>max_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>inSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>upSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>aroundSpeed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accelerate particles in a vortex-like way. 
<p>
The vortex is a complicated action to use, but when done correctly it makes particles fly around like in a tornado. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>center</em>&nbsp;</td><td>tip of the vortex </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>the ray along the center of the vortex </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tightnessExponent</em>&nbsp;</td><td>like a Phong exponent that gives a curve to the vortex silhouette; 1.0 is a cone; greater than 1.0 curves inward. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_radius</em>&nbsp;</td><td>defines the radius at the top of the vortex and the infinite cylinder of influence. No particle further than max_radius from the axis is affected. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inSpeed</em>&nbsp;</td><td>inward acceleration of particles OUTSIDE the vortex </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upSpeed</em>&nbsp;</td><td>vertical acceleration of particles INSIDE the vortex. Can be negative to apply gravity. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aroundSpeed</em>&nbsp;</td><td>acceleration around vortex of particles INSIDE the vortex. </td></tr>
  </table>
</dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Dec 30 11:28:40 2008 for ParticleAPI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
