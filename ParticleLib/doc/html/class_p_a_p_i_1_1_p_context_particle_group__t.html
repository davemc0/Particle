<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ParticleAPI: PContextParticleGroup_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_p_a_p_i.html">PAPI</a>::<a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html">PContextParticleGroup_t</a>
  </div>
</div>
<div class="contents">
<h1>PContextParticleGroup_t Class Reference</h1><!-- doxytag: class="PAPI::PContextParticleGroup_t" -->This class contains the API calls that operate on particle groups.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="p_a_p_i_8h-source.html">pAPI.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PContextParticleGroup_t:</div>
<div class="dynsection">

<p><center><img src="class_p_a_p_i_1_1_p_context_particle_group__t.png" usemap="#PContextParticleGroup_t_map" border="0" alt=""></center>
<map name="PContextParticleGroup_t_map">
<area href="class_p_a_p_i_1_1_particle_context__t.html" alt="ParticleContext_t" shape="rect" coords="0,56,150,80">
</map>
</div>

<p>
<a href="class_p_a_p_i_1_1_p_context_particle_group__t-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#897c8588c3760a7c5d0c7a32c26b9e5f">CopyGroup</a> (const int p_src_group_num, const size_t index=0, const size_t copy_count=<a class="el" href="namespace_p_a_p_i.html#4e6d6573f60c51b8ebddff9cd72a54d3">P_MAXINT</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy particles from the specified group into the current group.  <a href="#897c8588c3760a7c5d0c7a32c26b9e5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#f1ddcf82756a87ded68e545cad3e8d90">CurrentGroup</a> (const int p_group_num)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change which group is current.  <a href="#f1ddcf82756a87ded68e545cad3e8d90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#49aab2a3887103f5bbeccebef529a31b">DeleteParticleGroups</a> (const int p_group_num, const int p_group_count=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete one or more consecutive particle groups.  <a href="#49aab2a3887103f5bbeccebef529a31b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#d6b48bdc6e998672ff0df1c4f581230b">GenParticleGroups</a> (const int p_group_count=1, const size_t max_particles=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create particle groups, each with a maximum of max_particles.  <a href="#d6b48bdc6e998672ff0df1c4f581230b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#bbcc2cd2340624560e3b2cf6e9d5cb0c">GetGroupCount</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of particles existing in the current group.  <a href="#bbcc2cd2340624560e3b2cf6e9d5cb0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#b94327f011a4f3713cb0941abe0da63f">GetMaxParticles</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the maximum number of particles allowed in the current group.  <a href="#b94327f011a4f3713cb0941abe0da63f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#572fa2570b679e30dcce3b83454482ef">GetParticles</a> (const size_t index, const size_t count, float *position=NULL, float *color=NULL, float *vel=NULL, float *size=NULL, float *age=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy particles from the current group to application memory.  <a href="#572fa2570b679e30dcce3b83454482ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#5bce0365096e7fc132e3dce169670436">GetParticlePointer</a> (float *&amp;ptr, size_t &amp;stride, size_t &amp;pos3Ofs, size_t &amp;posB3Ofs, size_t &amp;size3Ofs, size_t &amp;vel3Ofs, size_t &amp;velB3Ofs, size_t &amp;color3Ofs, size_t &amp;alpha1Ofs, size_t &amp;age1Ofs, size_t &amp;up3Ofs, size_t &amp;rvel3Ofs, size_t &amp;upB3Ofs, size_t &amp;mass1Ofs, size_t &amp;data1Ofs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to particle data stored in API memory.  <a href="#5bce0365096e7fc132e3dce169670436"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#c89a60f3740531bba39533bf75d3e990">SetMaxParticles</a> (const size_t max_count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the maximum number of particles in the current group.  <a href="#c89a60f3740531bba39533bf75d3e990"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#25053af8e39685bf2bacd7c21832a41d">BirthCallback</a> (<a class="el" href="namespace_p_a_p_i.html#44ec24ae3e34ac482ea4dfcdf9fdd6c1">P_PARTICLE_CALLBACK</a> callback, puint64 group_data=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify a particle creation callback.  <a href="#25053af8e39685bf2bacd7c21832a41d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#e6eb3993e56f30524b0a902d789aa86c">DeathCallback</a> (<a class="el" href="namespace_p_a_p_i.html#44ec24ae3e34ac482ea4dfcdf9fdd6c1">P_PARTICLE_CALLBACK</a> callback, puint64 group_data=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify a particle death callback.  <a href="#e6eb3993e56f30524b0a902d789aa86c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#1112f0655c7c1b62f870511b8afef9d7">SetWorkingSetSize</a> (const int set_size_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the number of particles that fit in the CPU's cache.  <a href="#1112f0655c7c1b62f870511b8afef9d7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5c9df5b59ceb6b8d8584aaafc5a0609"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::InternalSetup" ref="a5c9df5b59ceb6b8d8584aaafc5a0609" args="(PInternalState_t *Sr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>InternalSetup</b> (PInternalState_t *Sr)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fdd40ca265daaa994d67e635ae63682c"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::PS" ref="fdd40ca265daaa994d67e635ae63682c" args="" -->
PInternalState_t *&nbsp;</td><td class="memItemRight" valign="bottom"><b>PS</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class contains the API calls that operate on particle groups. 
<p>
A particle group is first created using <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#d6b48bdc6e998672ff0df1c4f581230b" title="Create particle groups, each with a maximum of max_particles.">GenParticleGroups()</a>, which will create a sequentially-numbered set of particle groups and return the identifying number of the first generated particle group. You specify which group is current using <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#f1ddcf82756a87ded68e545cad3e8d90" title="Change which group is current.">CurrentGroup()</a>. Unless otherwise stated, all other commands operate on the current particle group. The maximum number of particles in the group is specified using <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#c89a60f3740531bba39533bf75d3e990" title="Change the maximum number of particles in the current group.">SetMaxParticles()</a>. The particle group is then acted upon using the Actions.<p>
After the actions have been applied, the particles are rendered. This is done at the same stage of the application's execution as drawing other geometry. To draw a particle group in OpenGL, the application calls <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#572fa2570b679e30dcce3b83454482ef" title="Copy particles from the current group to application memory.">GetParticles()</a> or <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#5bce0365096e7fc132e3dce169670436" title="Return a pointer to particle data stored in API memory.">GetParticlePointer()</a> functions to get the vertex data, then sends it to OpenGL. When a particle group is no longer needed, it is deleted using <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#49aab2a3887103f5bbeccebef529a31b" title="Delete one or more consecutive particle groups.">DeleteParticleGroups()</a>. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="25053af8e39685bf2bacd7c21832a41d"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::BirthCallback" ref="25053af8e39685bf2bacd7c21832a41d" args="(P_PARTICLE_CALLBACK callback, puint64 group_data=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BirthCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_p_a_p_i.html#44ec24ae3e34ac482ea4dfcdf9fdd6c1">P_PARTICLE_CALLBACK</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">puint64&nbsp;</td>
          <td class="paramname"> <em>group_data</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify a particle creation callback. 
<p>
Specify a callback function within your code that should be called every time a particle is created. The callback is associated only with the particle group that is current at the time you make the <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#25053af8e39685bf2bacd7c21832a41d" title="Specify a particle creation callback.">BirthCallback()</a> call. You can optionally pass a pointer to arbitrary data of your own, which is returned to your callback.<p>
The API's internal Particle_t struct is passed back to your callback function, so your application will have to include "ParticleLib/Particle.h", which it normally should not do. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Pointer to function of yours to call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group_data</em>&nbsp;</td><td>Arbitrary per-group data of yours to pass into your function </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="897c8588c3760a7c5d0c7a32c26b9e5f"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::CopyGroup" ref="897c8588c3760a7c5d0c7a32c26b9e5f" args="(const int p_src_group_num, const size_t index=0, const size_t copy_count=P_MAXINT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CopyGroup           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>p_src_group_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>copy_count</em> = <code><a class="el" href="namespace_p_a_p_i.html#4e6d6573f60c51b8ebddff9cd72a54d3">P_MAXINT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy particles from the specified group into the current group. 
<p>
Copy particles from the specified particle group, p_src_group_num, to the current particle group. Only copy_count particles, starting with number index are copied. Of course, the number of particles actually copied is bounded by the available space in the current particle group, and the number of particles actually in the source particle group. The particles are added, in sequential order, to the end of the current group. index is the index of the first particle in the source particle group to be copied. The group's <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#25053af8e39685bf2bacd7c21832a41d" title="Specify a particle creation callback.">BirthCallback()</a>, if any, is called for each particle added to the list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_src_group_num</em>&nbsp;</td><td>group number of the source particle group </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>index of the first particle in the source list to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_count</em>&nbsp;</td><td>copy at most this many particles </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f1ddcf82756a87ded68e545cad3e8d90"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::CurrentGroup" ref="f1ddcf82756a87ded68e545cad3e8d90" args="(const int p_group_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CurrentGroup           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>p_group_num</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change which group is current. 
<p>
Makes p_group_num be the current particle group to which all actions and commands apply. 
</div>
</div><p>
<a class="anchor" name="e6eb3993e56f30524b0a902d789aa86c"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::DeathCallback" ref="e6eb3993e56f30524b0a902d789aa86c" args="(P_PARTICLE_CALLBACK callback, puint64 group_data=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeathCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_p_a_p_i.html#44ec24ae3e34ac482ea4dfcdf9fdd6c1">P_PARTICLE_CALLBACK</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">puint64&nbsp;</td>
          <td class="paramname"> <em>group_data</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify a particle death callback. 
<p>
Specify a callback function within your code that should be called every time a particle is killed. The callback is associated only with the particle group that is current at the time you make the <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#e6eb3993e56f30524b0a902d789aa86c" title="Specify a particle death callback.">DeathCallback()</a> call. You can optionally pass a pointer to arbitrary data of your own, which is returned to your callback.<p>
The API's internal Particle_t struct is passed back to your callback function, so your application will have to include "ParticleLib/Particle.h", which it normally should not do. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Pointer to function of yours to call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group_data</em>&nbsp;</td><td>Arbitrary per-group data of yours to pass into your function </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="49aab2a3887103f5bbeccebef529a31b"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::DeleteParticleGroups" ref="49aab2a3887103f5bbeccebef529a31b" args="(const int p_group_num, const int p_group_count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeleteParticleGroups           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>p_group_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>p_group_count</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete one or more consecutive particle groups. 
<p>
Deletes p_group_count particle groups, with p_group_num being the particle group number of the first one. The groups must be numbered sequentially, and must all exist. This removes the specified particle groups from existence (and all their particles). It does not merely change the number of existing particles or the maximum size of the group.<p>
The DeathCallback is NOT called for the particles in the deleted groups. Should I change this? <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_group_num</em>&nbsp;</td><td>handle of the first particle group to delete </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_group_count</em>&nbsp;</td><td>delete this many groups </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d6b48bdc6e998672ff0df1c4f581230b"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::GenParticleGroups" ref="d6b48bdc6e998672ff0df1c4f581230b" args="(const int p_group_count=1, const size_t max_particles=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GenParticleGroups           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>p_group_count</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>max_particles</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create particle groups, each with a maximum of max_particles. 
<p>
Generates p_group_count new particle groups and returns the particle group number of the first one. The groups are numbered sequentially, beginning with the number returned. Each particle group is set to have at most max_particles particles. Call <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#c89a60f3740531bba39533bf75d3e990" title="Change the maximum number of particles in the current group.">SetMaxParticles()</a> to change this. Particle group numbers of groups that have been deleted (using <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#49aab2a3887103f5bbeccebef529a31b" title="Delete one or more consecutive particle groups.">DeleteParticleGroups()</a>) might be reused by <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#d6b48bdc6e998672ff0df1c4f581230b" title="Create particle groups, each with a maximum of max_particles.">GenParticleGroups()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_group_count</em>&nbsp;</td><td>generate this many groups </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_particles</em>&nbsp;</td><td>each created group can have this many particles </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bbcc2cd2340624560e3b2cf6e9d5cb0c"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::GetGroupCount" ref="bbcc2cd2340624560e3b2cf6e9d5cb0c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetGroupCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of particles existing in the current group. 
<p>
The number returned is less than or equal to the group's max_particles. 
</div>
</div><p>
<a class="anchor" name="b94327f011a4f3713cb0941abe0da63f"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::GetMaxParticles" ref="b94327f011a4f3713cb0941abe0da63f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetMaxParticles           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the maximum number of particles allowed in the current group. 
<p>
This can be changed with <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#c89a60f3740531bba39533bf75d3e990" title="Change the maximum number of particles in the current group.">SetMaxParticles()</a>. 
</div>
</div><p>
<a class="anchor" name="5bce0365096e7fc132e3dce169670436"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::GetParticlePointer" ref="5bce0365096e7fc132e3dce169670436" args="(float *&amp;ptr, size_t &amp;stride, size_t &amp;pos3Ofs, size_t &amp;posB3Ofs, size_t &amp;size3Ofs, size_t &amp;vel3Ofs, size_t &amp;velB3Ofs, size_t &amp;color3Ofs, size_t &amp;alpha1Ofs, size_t &amp;age1Ofs, size_t &amp;up3Ofs, size_t &amp;rvel3Ofs, size_t &amp;upB3Ofs, size_t &amp;mass1Ofs, size_t &amp;data1Ofs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetParticlePointer           </td>
          <td>(</td>
          <td class="paramtype">float *&amp;&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>pos3Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>posB3Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>size3Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>vel3Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>velB3Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>color3Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha1Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>age1Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>up3Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>rvel3Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>upB3Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>mass1Ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>data1Ofs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a pointer to particle data stored in API memory. 
<p>
This function exposes the internal storage of the particle data to the application. It provides a much higher performance way to render particles because it avoids copying. In fact, the returned pointers can typically be passed directly to OpenGL or D3D without the application ever owning a copy of the data.<p>
Writing to the returned memory is obviously unsafe. There may be auxiliary data that depend on the current values of the particle data. You can try it if you want to, but your code may break against future API versions. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the returned pointer to the particle data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stride</em>&nbsp;</td><td>the number of floats from one particle's value to the next particle's value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos3Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's position parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>posB3Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's positionB parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size3Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's size parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vel3Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's velocity parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>velB3Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's velocityB parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color3Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's color parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha1Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's alpha parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>age1Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's age parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>up3Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's up parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rvel3Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's rvel parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upB3Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's upB parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mass1Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's mass parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data1Ofs</em>&nbsp;</td><td>the number of floats from returned ptr to the first particle's data parameter, which is a 64-bit integer, not a float </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="572fa2570b679e30dcce3b83454482ef"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::GetParticles" ref="572fa2570b679e30dcce3b83454482ef" args="(const size_t index, const size_t count, float *position=NULL, float *color=NULL, float *vel=NULL, float *size=NULL, float *age=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetParticles           </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>color</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>vel</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>age</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy particles from the current group to application memory. 
<p>
Copies at most count particles beginning with the index-th particle in the current particle group into memory already allocated by the application. Three floats are returned for the position of each particle, representing its x,y,z location. Four floats are returned for the color of each particle, representing its R,G,B,A color. Three floats are returned for the velocity of each particle, representing its dx,dy,dz direction vector. Three floats are returned for the size of each particle, representing whatever the application wants them to. One float is returned for the age of each particle.<p>
<a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#572fa2570b679e30dcce3b83454482ef" title="Copy particles from the current group to application memory.">GetParticles()</a> returns the number of particles copied to application memory. Of course, the number of particles actually returned is bounded by count and by the number of particles actually in the particle group minus index. If verts, color, vel, size or age is NULL then the respective field will not be returned. index and count must be at least 0 and less than the number of particles. index + count must be less than the number of particles. As with all arrays in C, the index of the first particle is zero.<p>
The following code gets the position of all particles:<p>
int cnt = <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#bbcc2cd2340624560e3b2cf6e9d5cb0c" title="Returns the number of particles existing in the current group.">GetGroupCount()</a>; float *ppos = new float[cnt * 3]; int num_ret = GetParticles(0, cnt, ppos); <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>index of the first particle to return </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>max number of particles to return </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>location to store 3 floats per particle for position </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>location to store 4 floats per particle for color and alpha </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vel</em>&nbsp;</td><td>location to store 3 floats per particle for velocity </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>location to store 3 floats per particle for size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>age</em>&nbsp;</td><td>location to store 1 float per particle for age </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c89a60f3740531bba39533bf75d3e990"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::SetMaxParticles" ref="c89a60f3740531bba39533bf75d3e990" args="(const size_t max_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetMaxParticles           </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>max_count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change the maximum number of particles in the current group. 
<p>
If necessary, this will delete particles from the end of the particle group, but no other particles will be deleted. The <a class="el" href="class_p_a_p_i_1_1_p_context_particle_group__t.html#e6eb3993e56f30524b0a902d789aa86c" title="Specify a particle death callback.">DeathCallback()</a> of deleted particles WILL be called. Call SetMaxParticles(0) to empty the group. 
</div>
</div><p>
<a class="anchor" name="1112f0655c7c1b62f870511b8afef9d7"></a><!-- doxytag: member="PAPI::PContextParticleGroup_t::SetWorkingSetSize" ref="1112f0655c7c1b62f870511b8afef9d7" args="(const int set_size_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetWorkingSetSize           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>set_size_bytes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the number of particles that fit in the CPU's cache. 
<p>
You probably don't need to call this function. It is the number of bytes in the working set. Most action lists apply several actions to the working set of particles, then load the next working set of particles and apply the same actions to them. This allows particles to stay resident in the CPU's cache for a longer period of time, potentially increasing performance dramatically.<p>
You specify the working set size in bytes. The default is 768KB. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Dec 30 11:28:40 2008 for ParticleAPI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
